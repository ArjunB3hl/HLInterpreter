/* Generated By:JavaCC: Do not edit this line. HLEval.java Version 7.0.9 */
import java.util.*;
import java.util.ArrayDeque;
import java.util.ArrayList;
public class HLEval implements HLVisitor{
  public Object defaultVisit(SimpleNode node, Object data) throws Exception{
    node.childrenAccept(this, data);
    return data;
  }
  public Object visit(SimpleNode node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTbody node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTclause node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  
  
public Object visit(ASTvar_decl node, Object data) throws Exception {
    
    return null;
}


  public Object visit(ASTfn_decl node, Object data) throws Exception{
      
    return null;
  }
  public Object visit(ASTident_list node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  
  
  public Object visit(ASTfn_call node, Object data) throws Exception {
    
    // Get the function identifier
    
    
  
    
    SimpleNode child = (SimpleNode) node.jjtGetChild(0);
    Integer key = (Integer) child.jjtGetValue();
    
  
    
    ArrayDeque<HLActivationRecord> stack = HLActivation.getStack();
    int scopeId = ( (HLActivationRecord) HLActivation.currentScope()).getScopeId();
    int scope = scopeId;
    HLSymbTab table = null;
    HLSymbTabEntry entry = null;
   
    
    child = (SimpleNode) node.jjtGetChild(1);
    
    
    
    
    
    for(HLActivationRecord record: stack){
    
        if(record.getScopeId() == scope ){
            
            table = record.getSymbTab();
            entry = table.findEntry(key.intValue());
            
            if(entry!= null){
            
            table  = LocalScope.getSymbolTableByScope(entry.getScope(),key.intValue(),entry.getParamSize());
           
            break;
            
            }
            
            else{
             
             scope = scope - 1;
            
            
            }
        }
       
       
    } 
    
    ArrayList<KeyValue> keyValues = new ArrayList<>();
 
    for (int i = 0; i < child.jjtGetNumChildren(); i++) {
      Object argValue = child.jjtGetChild(i).jjtAccept(this, data);
      ArrayList<Integer> params = entry.getParam();
      key = params.get(i);
      KeyValue pair = new KeyValue(key.intValue(), argValue);
      keyValues.add(pair);
     
    }
    
    HLActivation.pushScope(entry.getScope());
    
    
    HLActivationRecord record = HLActivation.currentScope();
    record.addSymbTab(table);
    
    for(KeyValue keyValue: keyValues){
     record.addKeyValue(keyValue);
    }
    
    Object returnValue = null;
    try {
       SimpleNode body = (SimpleNode)  entry.getBody();
       body.jjtAccept(this, data);
    } catch (ReturnException re) {
         // Handle return statement
       

      
        

        // Retrieve the return value
      returnValue = re.getReturnValue();
        
   }
     // Pop the function activation key
          HLActivation.popScope();

     return returnValue;
}




  
  
  
  public Object visit(ASTboolean_call node, Object data) throws Exception {
   // Get the function identifier
    
    
  
    
    SimpleNode child = (SimpleNode) node.jjtGetChild(0);
    Integer key = (Integer) child.jjtGetValue();
    
  
    
    ArrayDeque<HLActivationRecord> stack = HLActivation.getStack();
    int scopeId = ( (HLActivationRecord) HLActivation.currentScope()).getScopeId();
    int scope = scopeId;
    HLSymbTab table = null;
    HLSymbTabEntry entry = null;
   
    
    child = (SimpleNode) node.jjtGetChild(1);
    
    
    
    
    
    for(HLActivationRecord record: stack){
    
        if(record.getScopeId() == scope ){
            
            table = record.getSymbTab();
            entry = table.findEntry(key.intValue());
            
            if(entry!= null){
            
            table  = LocalScope.getSymbolTableByScope(entry.getScope(),key.intValue(),entry.getParamSize());
           
            break;
            
            }
            
            else{
             
             scope = scope - 1;
            
            
            }
        }
       
       
    } 
    
    ArrayList<KeyValue> keyValues = new ArrayList<>();
 
    for (int i = 0; i < child.jjtGetNumChildren(); i++) {
      Object argValue = child.jjtGetChild(i).jjtAccept(this, data);
      ArrayList<Integer> params = entry.getParam();
      key = params.get(i);
      KeyValue pair = new KeyValue(key.intValue(), argValue);
      keyValues.add(pair);
     
    }
    
    HLActivation.pushScope(entry.getScope());
    
    
    HLActivationRecord record = HLActivation.currentScope();
    record.addSymbTab(table);
    
    for(KeyValue keyValue: keyValues){
     record.addKeyValue(keyValue);
    }
    
    Object returnValue = null;
    try {
       SimpleNode body = (SimpleNode)  entry.getBody();
       body.jjtAccept(this, data);
    } catch (ReturnException re) {
         // Handle return statement
       

      
        

        // Retrieve the return value
      returnValue = re.getReturnValue();
        
   }
     // Pop the function activation key
          HLActivation.popScope();

     return returnValue;
    
}

  
  
  
  
  public Object visit(ASTvalue_list node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  
  
  public Object visit(ASTReturn node, Object data) throws Exception {
    Object returnValue = null;
    if (node.jjtGetNumChildren() > 0) {
        returnValue = node.jjtGetChild(0).jjtAccept(this, data);
    }
    throw new ReturnException(returnValue);
    }

  



public Object visit(ASTAssign node, Object data) throws Exception {

   
    // First child is the identifier node (lhs)
    SimpleNode identifierNode = (SimpleNode) node.jjtGetChild(0);
    Integer key = (Integer) identifierNode.jjtGetValue();
    
    
    // Second child is the value/expression (rhs)
    Object value = node.jjtGetChild(1).jjtAccept(this, data);
  
    

    // Search for the activation record for this key
    // Search for the activation record for this key
    ArrayDeque<HLActivationRecord> stack = HLActivation.getStack();
    int scopeId = ( (HLActivationRecord) HLActivation.currentScope()).getScopeId();
    int scope = scopeId;

    
    for(HLActivationRecord record: stack){
    
        if(record.getScopeId() == scope ){
          
           if( record.findValue(key.intValue()) != null ){
           
                record.setValue(key, value);
                
                break;  
             }
            
            HLSymbTab table = record.getSymbTab();
            HLSymbTabEntry entry = table.findEntry(key.intValue());
            
            if(entry!= null){
            
             record.addKeyValue(new KeyValue(key.intValue(), value)); 
            
             break;  
            
            }
            
            else{
             
             scope = scope - 1;
            
            
            }
        }
       
        } 
        

    return null;
}

  
 


public Object visit(ASTPrint node, Object data) throws Exception {

    for (int i = 0; i < node.jjtGetNumChildren(); i++) {
        node.jjtGetChild(i).jjtAccept(this, null); 
    }
    return null;
}

public Object visit(ASTPrintln node, Object data) throws Exception {

    for (int i = 0; i < node.jjtGetNumChildren(); i++) {
        
        node.jjtGetChild(i).jjtAccept(this, null); 
    }
    System.out.println(); 
    return null;
}

  public Object visit(ASTprint_list node, Object data) throws Exception{
    for (int i = 0; i < node.jjtGetNumChildren(); i++) {
    
    if (node.jjtGetChild(i).jjtAccept(this, null) instanceof Boolean) {
            System.out.print((Boolean) node.jjtGetChild(i).jjtAccept(this, null) ? "true" : "false");
        } else {
            System.out.print(node.jjtGetChild(i).jjtAccept(this, null));  
        }
        
    }
    
    

    return null;
  }
  
  public Object visit(ASTIf node, Object data) throws Exception{
  
    
    if ( node.jjtGetChild(0).jjtAccept(this, null) instanceof Boolean && ((Boolean) node.jjtGetChild(0).jjtAccept(this, null)).booleanValue()) {
            
        node.jjtGetChild(1).jjtAccept(this, null);
     }
     
     
    else {
             
        node.jjtGetChild(2).jjtAccept(this, null);
             
      }
             
             
        
        
  
    return null;
  }
  
  public Object visit(ASTNULL node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  public Object visit(ASTFor node, Object data) throws Exception{
     SimpleNode child =  (SimpleNode) node.jjtGetChild(0);
     Integer key = (Integer) child.jjtGetValue();
    
    // HLNameStack stack = HLSymbTab.getStack(key);
   // HLIdTab topElement = stack.peek();
  
     child = (SimpleNode) node.jjtGetChild(1);
     Object value;
     ArrayDeque<HLActivationRecord> stack = HLActivation.getStack();
    int scopeId = ( (HLActivationRecord) HLActivation.currentScope()).getScopeId();
    int scope = scopeId;
    HLActivationRecord mainRecord = null;
    for(HLActivationRecord record: stack){
    
        if(record.getScopeId() == scope ){
          
           if( record.findValue(key.intValue()) != null ){
           
                mainRecord = record; 
                break;  
            
            
            
            }
            
            HLSymbTab table = record.getSymbTab();
            HLSymbTabEntry entry = table.findEntry(key.intValue());
            
            if(entry!= null){
            
             record.addKeyValue(new KeyValue(key.intValue(), null)); 
             mainRecord = record;
             break;  
            
            }
            
            else{
             
             scope = scope - 1;
            
            
            }
        }
       
        } 
     for (int i = 0; i < child.jjtGetNumChildren(); i++) {
     value = ((SimpleNode)child.jjtGetChild(i)).jjtAccept(this, data);
      
       if(  value instanceof HLNumber){

           
         mainRecord.setValue(key.intValue(), value); // Update the value if the record exists
         
         node.jjtGetChild(2).jjtAccept(this, data);
      
       }
       else if(value instanceof HLSet){
           Iterator<Integer> iter;
           iter = ( (TreeSet<Integer>) ((HLSet)value).get()).iterator();
           while (iter.hasNext()) {
            
            mainRecord.setValue(key.intValue(),new HLNumber(iter.next())); // Update the value if the record exists
            node.jjtGetChild(2).jjtAccept(this, data);
            
           }
        
       
      }
    
    }
  
    return null;
  }
  public Object visit(ASTexp_list node, Object data) throws Exception{
    return defaultVisit(node, data);
  }
  
  public Object visit(ASTWhile node, Object data) throws Exception {
   
    while (true) {
         Object condValue = node.jjtGetChild(0).jjtAccept(this, data);
        
       if (!(condValue instanceof Boolean)) {
           throw new IllegalArgumentException("While condition must be boolean");
       }
         boolean cond = (Boolean) condValue;
       if (cond) {
            
        node.jjtGetChild(1).jjtAccept(this, data);
        
        }
      else{
        break;
      
      }
         
     }
    
    return null;
}

  
  public Object visit(ASTor node, Object data) throws Exception {
    for (int i = 0; i < node.jjtGetNumChildren(); i++) {
        Object value = node.jjtGetChild(i).jjtAccept(this, data);

        if (value instanceof Boolean && (Boolean) value) {
            
            return true;
        }
    }
  
    return false;
}

  
  public Object visit(ASTand node, Object data) throws Exception {
    for (int i = 0; i < node.jjtGetNumChildren(); i++) {
        Object value = node.jjtGetChild(i).jjtAccept(this, data);

        if (value instanceof Boolean && !(Boolean) value) {
            
            return false;
        }
    }
    
    return true;
}


public Object visit(ASTnot node, Object data) throws Exception {
    
    Object value = node.jjtGetChild(0).jjtAccept(this, data);
   
   
    if (value instanceof Boolean) {
        return !(Boolean) value;
    }

    throw new IllegalArgumentException("ASTnot expects a boolean expression");
}

  public Object visit(ASTTRUE node, Object data) throws Exception{
    
    return true;
  }
  public Object visit(ASTFALSE node, Object data) throws Exception{
    
    return false;
  }
  
  
 
  public Object visit(ASTcomparison node, Object data) throws Exception {
   
    
     
    
    Object left = node.jjtGetChild(0).jjtAccept(this, data);
    


    Object comparator = node.jjtGetChild(1).jjtAccept(this, data);

  
    Object right = node.jjtGetChild(2).jjtAccept(this, data);

   
   if (left instanceof HLObject && right instanceof HLObject){
   
          if (comparator instanceof ASTLESS ) {
              return ((HLObject)left).isLessThan((HLObject)right);
          } else if (comparator instanceof ASTLESSEQ   ) {
              
              return (  ((HLObject)left).isLessThan((HLObject)right)  ||  ((HLObject) left).isSame((HLObject) right)  );
          } else if (comparator instanceof ASTGREATER  ) {
          
          if(left instanceof HLSet && right instanceof HLSet){
          
              return (  ((HLSet)left).isGreatThan((HLSet)right)  );
              
              }
              
              else {
              
              
              return (  ((HLNumber)left).isGreatThan((HLNumber)right)   );
              
              }
               
               
               
               
          } else if (comparator instanceof ASTGREATEQ  ) {
              if(left instanceof HLSet && right instanceof HLSet){
          
              return (  ((HLSet)left).isGreatThan((HLSet)right)  ||   ((HLSet) left).isSame((HLSet) right)  );
              
              }
              
              else {
           
            boolean result = ((HLNumber) left).isGreatThan((HLNumber) right) || ((HLNumber) left).isSame((HLNumber) right);
           
            return result;

              }
              
          } else if (comparator instanceof ASTEQUAL ) {
              return ((HLObject) left).isSame((HLObject) right) ;
          } else if (comparator instanceof ASTNOTEQ) {
              return !(((HLObject) left).isSame((HLObject) right));
          } 
           else if (comparator instanceof ASTISIN ) {
              return ((HLSet) right).contains((HLNumber) left) ;
          } else if (comparator instanceof ASTNOTIN) {
              return !(((HLSet) right).contains((HLNumber) left));
          } 
          
          
  }
    throw new UnsupportedOperationException("Unknown comparator: " + comparator);
}

  
  public Object visit(ASTLESS node, Object data) throws Exception{
    return node;
  }
  public Object visit(ASTLESSEQ node, Object data) throws Exception{
    return node;
  }
  public Object visit(ASTGREATER node, Object data) throws Exception{
    return node;
  }
  public Object visit(ASTGREATEQ node, Object data) throws Exception{
    return node;
  }
  public Object visit(ASTEQUAL node, Object data) throws Exception{
    return node;
  }
  public Object visit(ASTNOTEQ node, Object data) throws Exception{
    return node;
  }
  public Object visit(ASTISIN node, Object data) throws Exception{
    return node;
  }
  public Object visit(ASTNOTIN node, Object data) throws Exception{
    return node;
  }


public Object visit(ASTsum node, Object data) throws Exception {
    // Initialize result with the first child's evaluation
    HLObject result;

    // Handle the first child node
    Object firstChild = node.jjtGetChild(0);
    Object childResult = ((SimpleNode) firstChild).jjtAccept(this, null);

    if (firstChild instanceof ASTneg) {
        result = ((HLObject) ((SimpleNode) firstChild).jjtGetChild(0).jjtAccept(this, null)).negate();
    } else if (firstChild instanceof ASTpos) {
        result = (HLObject) ((SimpleNode) firstChild).jjtGetChild(0).jjtAccept(this, null);
    } else if (childResult instanceof HLObject) {
        result = (HLObject) childResult;
    } else {
        throw new IllegalArgumentException("Unexpected child node type in ASTsum");
    }

    // Iterate through the remaining children
    for (int i = 1; i < node.jjtGetNumChildren(); i++) {
        SimpleNode currentChild = (SimpleNode) node.jjtGetChild(i);
        childResult = currentChild.jjtAccept(this, null);

        if (currentChild instanceof ASTneg) {
            result = result.sub((HLObject) currentChild.jjtGetChild(0).jjtAccept(this, null));
        } else if (currentChild instanceof ASTpos) {
            result = result.add((HLObject) currentChild.jjtGetChild(0).jjtAccept(this, null));
        } else {
            throw new IllegalArgumentException("Unexpected child node type in ASTsum");
        }
    }

    return result;
}

 

public Object visit(ASTneg node, Object data) throws Exception {
   return node;
}

public Object visit(ASTpos node, Object data) throws Exception {
    return node;
}


public Object visit(ASTmul node, Object data) throws Exception {
    // Initialize the result based on the type of the first child
    Object childResult = node.jjtGetChild(0).jjtAccept(this, null);

    if (!(childResult instanceof HLObject)) {
        throw new IllegalArgumentException("Expected HLObject, but got: " + childResult.getClass().getName());
    }

    HLObject result = (HLObject) childResult;

    // Iterate through the remaining child nodes
    for (int i = 1; i < node.jjtGetNumChildren(); i++) {
        childResult = node.jjtGetChild(i).jjtAccept(this, null);

        if (!(childResult instanceof HLObject)) {
            throw new IllegalArgumentException("Expected HLObject, but got: " + childResult.getClass().getName());
        }

        HLObject current = (HLObject) childResult;

        if (result instanceof HLNumber && current instanceof HLNumber) {
            result = ((HLNumber) result).mul((HLNumber) current);
        } else if (result instanceof HLSet && current instanceof HLSet) {
            result = ((HLSet) result).mul((HLSet) current);
        } else {
            throw new IllegalArgumentException("Multiplication is not supported between types: " +
                result.getClass().getName() + " and " + current.getClass().getName());
        }
    }

    return result;
}

  
  
    
    public Object visit(ASTdiv node, Object data) throws Exception {
        Object firstChildResult = node.jjtGetChild(0).jjtAccept(this, null);
        if (!(firstChildResult instanceof HLNumber)) {
            throw new IllegalArgumentException("Expected HLNumber, but got: " + firstChildResult.getClass().getName());
        }
        HLNumber result = (HLNumber) firstChildResult;
    
        for (int i = 1; i < node.jjtGetNumChildren(); i++) {
            Object childResult = node.jjtGetChild(i).jjtAccept(this, null);
            if (childResult instanceof HLNumber) {
                result = result.div((HLNumber) childResult);
            } else {
                throw new IllegalArgumentException("Expected HLNumber, but got: " + childResult.getClass().getName());
            }
        }
        return result;
    }
    
    public Object visit(ASTmod node, Object data) throws Exception {
        Object firstChildResult = node.jjtGetChild(0).jjtAccept(this, null);
        if (!(firstChildResult instanceof HLNumber)) {
            throw new IllegalArgumentException("Expected HLNumber, but got: " + firstChildResult.getClass().getName());
        }
        HLNumber result = (HLNumber) firstChildResult;
    
        for (int i = 1; i < node.jjtGetNumChildren(); i++) {
            Object childResult = node.jjtGetChild(i).jjtAccept(this, null);
            if (childResult instanceof HLNumber) {
                result = result.mod((HLNumber) childResult);
            } else {
                throw new IllegalArgumentException("Expected HLNumber, but got: " + childResult.getClass().getName());
            }
        }
        return result;
    }
   

  
  
  
  
  
  public Object visit(ASTAbsolute_value node, Object data) throws Exception {
      // Visit the child node and expect an HLNumber
    
      Object childResult = node.jjtGetChild(0).jjtAccept(this, null);
      if (childResult instanceof HLObject) {
          HLObject childNumber = (HLObject) childResult;
          // Use the card method to get the absolute value
          return childNumber.card();
      } else {
          throw new IllegalArgumentException("Expected HLObject, but got: " + childResult.getClass().getName());
      }

    
    
  }

  
  
  
  
  public Object visit(ASTinterval node, Object data) throws Exception {
      Object left = node.jjtGetChild(0).jjtAccept(this, null);
      Object right = node.jjtGetChild(1).jjtAccept(this, null);
      return new HLSet((HLNumber)left, (HLNumber)right);
}

  public Object visit(ASTset_former node, Object data) throws Exception{
     SimpleNode child = (SimpleNode) node.jjtGetChild(0);
        Integer key = (Integer) child.jjtGetValue();
        
        // Get the current scope ID
        int scopeId = ((HLActivationRecord) HLActivation.currentScope()).getScopeId();
        

        int scope = scopeId;

        // Create a new symbol table and entry
        HLSymbTab table = new HLSymbTab(scope + 1);
        HLSymbTabEntry entry = new HLSymbTabEntry(key.intValue(), HLConstants.IDNUM);
        table.addEntry(entry);
        

        // Push the new scope
        HLActivation.pushScope(table.getTableId());
        HLActivationRecord record = HLActivation.currentScope();
        record.addSymbTab(table);
        record.addKeyValue(new KeyValue(key.intValue(), new HLNumber(0)));
        

        // Process the second child
        Object value = node.jjtGetChild(1).jjtAccept(this, null);
        

        TreeSet<Integer> treeSet = new TreeSet<>();

        // Check if value is an HLSet
        if (value instanceof HLSet) {
            Iterator<Integer> iter = ((TreeSet<Integer>) ((HLSet) value).get()).iterator();
            

            while (iter.hasNext()) {
                int currentValue = iter.next();
                record.setValue(key.intValue(), new HLNumber(currentValue));


                // Evaluate the third child
                boolean condition = (Boolean) node.jjtGetChild(2).jjtAccept(this, data);

                if (condition) {
                    treeSet.add(currentValue);
                
                }
            }
        }

        // Pop the current scope
        HLActivation.popScope();
        

        // Return the resulting set
        return new HLSet(treeSet);
    
    
    
  }


public Object visit(ASTset node, Object data) throws Exception {

 TreeSet<Integer> treeSet = new TreeSet<>();

    
    for (int i = 0; i < node.jjtGetNumChildren(); i++) {
        Object result = node.jjtGetChild(i).jjtAccept(this, null);

        // Add the result to the TreeSet
        if (result instanceof HLNumber) {
            treeSet.add( ((HLNumber) result).getValue());
        } else {
            throw new Exception("Set elements must be numeric");
        }
    }

    
    return new HLSet(treeSet);
}



public Object visit(ASTidentifier node, Object data) throws Exception {



    // Get the key associated with this identifier node
    Integer key = (Integer) node.jjtGetValue();

    

    // Search for the activation record for this key
    ArrayDeque<HLActivationRecord> stack = HLActivation.getStack();
    int scopeId = ( (HLActivationRecord) HLActivation.currentScope()).getScopeId();
    int scope = scopeId;
    Object value = null;
    for( HLActivationRecord record: stack){
    
        if(record.getScopeId() == scope ){
          
           if( record.findValue(key.intValue()) != null ){
           
           
                value = record.findValue(key.intValue());  
              
                break;  
            
            
            
            }
            
            else{
             
             scope = scope - 1;
            
            
            }
        }
       
        } 
        
    scope = scopeId;
    if( value == null){
    
     
       for( HLActivationRecord record: stack){
       
          HLSymbTab table = record.getSymbTab();
          if(record.getScopeId() == scope ){
              
              HLSymbTabEntry entry = table.findEntry(key.intValue());
              if(entry!= null){
           
                 if(entry.getType() == HLConstants.IDNUM){
                   
                   
                   
                   record.addKeyValue(new KeyValue(key.intValue(), new HLNumber(0) ));
                   
               
                     value = new HLNumber(0); 
                    
                     break;
               
               
                 }
               
                 else if(entry.getType() == HLConstants.IDSET){
               
               
                     record.addKeyValue(new KeyValue(key.intValue(), new HLSet() ));
                 
               
                     value = new HLSet();
            
                     break;
               
               
                 }
              
              
                  else  if(entry.getType() == HLConstants.IDBOOL){
               
               
                      record.addKeyValue(new KeyValue(key.intValue(), false ));
                 
               
                    value =  false;
              
                    break;
               
                 }
              
              
              }
          
              else{
              
              scope = scope -1;
              
              
              }
           
         
            }
        }
    
    
    }
        

    
   return value; 
   
    
     
}

 


  public Object visit(ASTtypenum node, Object data) throws Exception{
    return node.jjtGetValue();
  }
  public Object visit(ASTtypeset node, Object data) throws Exception{
    return node.jjtGetValue();
  }
  public Object visit(ASTtypebool node, Object data) throws Exception{
    return node.jjtGetValue();
  }
  public Object visit(ASTnumber node, Object data) throws Exception{
      
  
      return new HLNumber(((Integer) node.jjtGetValue()).intValue());
  }
  
  
  public Object visit(ASTstring node, Object data) throws Exception {
    
    
    return node.jjtGetValue();
}


}
/* JavaCC - OriginalChecksum=5fed741071bb7da1c3cb2cfb13af7ff9 (do not edit this line) */



